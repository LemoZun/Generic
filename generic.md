# Generic

## 제네릭이란
제네릭은 자료형의 형식을 지정하지 않고 데이터 형식을 일반화 해서 재사용 가능한 코드를 작성하는 것으로 기능을 구현한 뒤 자료형의 형식을 지정해서 사용한다.

## 제네릭의 사용처
제네릭은 서로 다른 데이터 형식에 대해 동일한 기능을 수행해야 할 경우나 반대로 데이터 형식에 따라 다른 기능을 수행해야 할 때 사용할 수 있으며, 데이터베이스에서 데이터를 가져올 때 다양한 데이터 형식을 저장하고 관리하게 되는데 데이터 형식까지 제공하지는 않는 데이터베이스를 사용할 때 유용하다. 

## 제네릭의 형식 제약 조건
제약 조건은 형식 인수에서 갖춰야 하는 기능을 컴파일러에 알리는 기능을 하며, 제약 조건이 없다면 인수는 어떠한 형식도 될 수 있다. 
where 키워드를 사용해 설정 가능하다.
- where T : struct → 형식 인수로 값 형식만을 사용하는 제약조건이다.
- where T : class → 형식 인수로 참조형식만들 사용하는 제약조건이다.

### 제약조건을 사용하는 이유
제약 조건은 형식 매개변수의 기능과 기대치를 지정해 제약조건을 선언하면 제약 형식의 작업과 메서드 호출을 할 수 있다. 
타입을 잘못 지정할 경우, 런타임때 제네릭을 인식해 타입의 안정성을 보장하며 박싱 언박싱에 비해 성능과 자원을 아낄 수 있다.

## 제네릭과 박싱/언박싱
제네릭의 사용 이유중 하나는 박싱 언박싱 문제를 해결하기 위함으로, 
 박싱은 값타입을 오브젝트 타입(참조형식)으로 변환하는 것을 뜻하며 스택에 있는 데이터를 힙으로 복사하는 작업이다. 값타입을 조금 더 큰 영역인 오브젝트 타입으로 포장한다고 생각하면 이해가 쉽다. 언박싱은 그 반대로, 오브젝트 타입을 값타입으로 변환하는 것이며 힙에 있던 데이터를 스택 영역으로 복사를 하는 과정이다. 즉 포장을 하던 박싱과는 반대로 포장을 푸는 것이다. 이러한 박싱과 언박싱 과정은 단순하게 참조에 할당하는것에 비해 시간이 많이 소요되어 사용을 지양해야 한다.

 제네릭은 이러한 박싱 언박싱 과정을 거치지 않기 위해 제약 조건을 설정하는것으로 개체의 타입을 지정해서 작업을 수행 할 수 있다. 
 
 - tmi : foreach문의 경우 내부에서 박싱이 일어나지만 반복시킬 대상이 참조형식일 경우 박싱과정이 일어나지 않으므로 참조형식을 반복하는 용도의 foreach문은 사용을 지양하지 않아도 괜찮다.

## 제네릭과 템플릿 
C#에 제네릭이 있다면 C++에는 템플릿이 있다. 두경우 모두 매개변수가 있는 형식을 지원하는 언어 기능이지만 서로 많은 차이점이 존재한다. 제네릭은 더 간단한 접근 방식으로 템플릿에 비해 간단하지만 템플릿에서 제공하는 기능 중 일부를 제공하지 않는다.
제네릭과 템플릿의 주요 차이점은 다음과 같다.
  
- 제네릭은 런타임때 형식으로 대체될 때까지 제네릭이지만 템플릿은 컴파일때 특수화되어 런타임때는 아직 매개변수가 있는 형식이 아니다.
- 제네릭은 비형식 템플릿 매개 변수를 허용하지 않지만 템플릿은 허용한다. EX) template C\<int i> {} 
- 제네릭은 특정 형식에 대한 템플릿의 사용자 지정 구현(명시적 특수화)을 허용하지 않지만 템플릿은 허용한다.
- 제네릭은 형식 매개변수를 제네릭 형식에 대한 기본 클래스나 기본형식으로 사용할 수 없다.

템플릿 : 자동으로 해당 자료형의 함수를 만들어 주는 기능
  원시자료형을 쓰기 때문에 일반화 타입을 만들 수 없다
제네릭 : 모든 타입들이 클래스나 구조체로 구현되어 있고 모두 object를 상속해서 만들어졌다. 고로 어떤 자료형도 대응 할 수 있는 일반화 함수를 만드는게 가능하다. 단 박싱 번박싱 과정을 배제하기 위해 제약조건을 걸어 특정한 자료 형식만을 사용하도록 제약해 줄 수 있다. 

C++과 C#의 차이는 가상머신을 사용하느냐의 차이 - C#은 자바처럼 가상머신을 이용해서 컴파일한다.